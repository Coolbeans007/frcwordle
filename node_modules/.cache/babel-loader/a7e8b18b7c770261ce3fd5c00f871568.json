{"ast":null,"code":"// In the absence of a WeakSet or WeakMap implementation, don't break, but don't cache either.\nfunction noop() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n}\n\nfunction createWeakMap() {\n  if (typeof WeakMap !== \"undefined\") {\n    return new WeakMap();\n  } else {\n    return fakeSetOrMap();\n  }\n}\n/**\n * Creates and returns a no-op implementation of a WeakMap / WeakSet that never stores anything.\n */\n\n\nfunction fakeSetOrMap() {\n  return {\n    add: noop,\n    delete: noop,\n    get: noop,\n    set: noop,\n    has: function (k) {\n      return false;\n    }\n  };\n} // Safe hasOwnProperty\n\n\nvar hop = Object.prototype.hasOwnProperty;\n\nvar has = function (obj, prop) {\n  return hop.call(obj, prop);\n}; // Copy all own enumerable properties from source to target\n\n\nfunction extend(target, source) {\n  for (var prop in source) {\n    if (has(source, prop)) {\n      target[prop] = source[prop];\n    }\n  }\n\n  return target;\n}\n\nvar reLeadingNewline = /^[ \\t]*(?:\\r\\n|\\r|\\n)/;\nvar reTrailingNewline = /(?:\\r\\n|\\r|\\n)[ \\t]*$/;\nvar reStartsWithNewlineOrIsEmpty = /^(?:[\\r\\n]|$)/;\nvar reDetectIndentation = /(?:\\r\\n|\\r|\\n)([ \\t]*)(?:[^ \\t\\r\\n]|$)/;\nvar reOnlyWhitespaceWithAtLeastOneNewline = /^[ \\t]*[\\r\\n][ \\t\\r\\n]*$/;\n\nfunction _outdentArray(strings, firstInterpolatedValueSetsIndentationLevel, options) {\n  // If first interpolated value is a reference to outdent,\n  // determine indentation level from the indentation of the interpolated value.\n  var indentationLevel = 0;\n  var match = strings[0].match(reDetectIndentation);\n\n  if (match) {\n    indentationLevel = match[1].length;\n  }\n\n  var reSource = \"(\\\\r\\\\n|\\\\r|\\\\n).{0,\" + indentationLevel + \"}\";\n  var reMatchIndent = new RegExp(reSource, \"g\");\n\n  if (firstInterpolatedValueSetsIndentationLevel) {\n    strings = strings.slice(1);\n  }\n\n  var newline = options.newline,\n      trimLeadingNewline = options.trimLeadingNewline,\n      trimTrailingNewline = options.trimTrailingNewline;\n  var normalizeNewlines = typeof newline === \"string\";\n  var l = strings.length;\n  var outdentedStrings = strings.map(function (v, i) {\n    // Remove leading indentation from all lines\n    v = v.replace(reMatchIndent, \"$1\"); // Trim a leading newline from the first string\n\n    if (i === 0 && trimLeadingNewline) {\n      v = v.replace(reLeadingNewline, \"\");\n    } // Trim a trailing newline from the last string\n\n\n    if (i === l - 1 && trimTrailingNewline) {\n      v = v.replace(reTrailingNewline, \"\");\n    } // Normalize newlines\n\n\n    if (normalizeNewlines) {\n      v = v.replace(/\\r\\n|\\n|\\r/g, function (_) {\n        return newline;\n      });\n    }\n\n    return v;\n  });\n  return outdentedStrings;\n}\n\nfunction concatStringsAndValues(strings, values) {\n  var ret = \"\";\n\n  for (var i = 0, l = strings.length; i < l; i++) {\n    ret += strings[i];\n\n    if (i < l - 1) {\n      ret += values[i];\n    }\n  }\n\n  return ret;\n}\n\nfunction isTemplateStringsArray(v) {\n  return has(v, \"raw\") && has(v, \"length\");\n}\n/**\n * It is assumed that opts will not change.  If this is a problem, clone your options object and pass the clone to\n * makeInstance\n * @param options\n * @return {outdent}\n */\n\n\nfunction createInstance(options) {\n  /** Cache of pre-processed template literal arrays */\n  var arrayAutoIndentCache = createWeakMap();\n  /**\n     * Cache of pre-processed template literal arrays, where first interpolated value is a reference to outdent,\n     * before interpolated values are injected.\n     */\n\n  var arrayFirstInterpSetsIndentCache = createWeakMap();\n\n  function outdent(stringsOrOptions) {\n    var values = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      values[_i - 1] = arguments[_i];\n    }\n    /* tslint:enable:no-shadowed-variable */\n\n\n    if (isTemplateStringsArray(stringsOrOptions)) {\n      var strings = stringsOrOptions; // Is first interpolated value a reference to outdent, alone on its own line, without any preceding non-whitespace?\n\n      var firstInterpolatedValueSetsIndentationLevel = (values[0] === outdent || values[0] === defaultOutdent) && reOnlyWhitespaceWithAtLeastOneNewline.test(strings[0]) && reStartsWithNewlineOrIsEmpty.test(strings[1]); // Perform outdentation\n\n      var cache = firstInterpolatedValueSetsIndentationLevel ? arrayFirstInterpSetsIndentCache : arrayAutoIndentCache;\n      var renderedArray = cache.get(strings);\n\n      if (!renderedArray) {\n        renderedArray = _outdentArray(strings, firstInterpolatedValueSetsIndentationLevel, options);\n        cache.set(strings, renderedArray);\n      }\n      /** If no interpolated values, skip concatenation step */\n\n\n      if (values.length === 0) {\n        return renderedArray[0];\n      }\n      /** Concatenate string literals with interpolated values */\n\n\n      var rendered = concatStringsAndValues(renderedArray, firstInterpolatedValueSetsIndentationLevel ? values.slice(1) : values);\n      return rendered;\n    } else {\n      // Create and return a new instance of outdent with the given options\n      return createInstance(extend(extend({}, options), stringsOrOptions || {}));\n    }\n  }\n\n  var fullOutdent = extend(outdent, {\n    string: function (str) {\n      return _outdentArray([str], false, options)[0];\n    }\n  });\n  return fullOutdent;\n}\n\nvar defaultOutdent = createInstance({\n  trimLeadingNewline: true,\n  trimTrailingNewline: true\n}); // Named exports.  Simple and preferred.\n// import outdent from 'outdent';\n\nexport default defaultOutdent; // import {outdent} from 'outdent';\n\nexport { defaultOutdent as outdent };\n\nif (typeof module !== \"undefined\") {\n  // In webpack harmony-modules environments, module.exports is read-only,\n  // so we fail gracefully.\n  try {\n    module.exports = defaultOutdent;\n    Object.defineProperty(defaultOutdent, \"__esModule\", {\n      value: true\n    });\n    defaultOutdent.default = defaultOutdent;\n    defaultOutdent.outdent = defaultOutdent;\n  } catch (e) {}\n}","map":{"version":3,"sources":["/Users/ntwrkman/Desktop/frcwordl/node_modules/outdent/src/index.ts"],"names":[],"mappings":"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","sourcesContent":["type TODO = any;\n\n// In the absence of a WeakSet or WeakMap implementation, don't break, but don't cache either.\nfunction noop(...args: Array<any>) {}\nfunction createWeakMap<K extends object, V>(): MyWeakMap<K, V> {\n  if (typeof WeakMap !== \"undefined\") {\n    return new WeakMap<K, V>();\n  } else {\n    return fakeSetOrMap<K, V>();\n  }\n}\n\ntype MyWeakMap<K extends object, V> = Pick<\n  WeakMap<K, V>,\n  \"delete\" | \"get\" | \"set\" | \"has\"\n>;\ntype MyWeakSetMap<K extends object, V> =\n  & Pick<WeakMap<K, V>, \"delete\" | \"get\" | \"set\" | \"has\">\n  & Pick<WeakSet<K>, \"add\">;\n\n/**\n * Creates and returns a no-op implementation of a WeakMap / WeakSet that never stores anything.\n */\nfunction fakeSetOrMap<K extends object, V = any>(): MyWeakSetMap<K, V> {\n  return {\n    add: noop as WeakSet<K>[\"add\"],\n    delete: noop as WeakMap<K, V>[\"delete\"],\n    get: noop as WeakMap<K, V>[\"get\"],\n    set: noop as WeakMap<K, V>[\"set\"],\n    has(k: K) {\n      return false;\n    },\n  };\n}\n\n// Safe hasOwnProperty\nconst hop = Object.prototype.hasOwnProperty;\nconst has = function (obj: object, prop: string): boolean {\n  return hop.call(obj, prop);\n};\n\n// Copy all own enumerable properties from source to target\nfunction extend<T, S extends object>(target: T, source: S) {\n  type Extended = T & S;\n  for (const prop in source) {\n    if (has(source, prop)) {\n      (target as any)[prop] = source[prop];\n    }\n  }\n  return target as Extended;\n}\n\nconst reLeadingNewline = /^[ \\t]*(?:\\r\\n|\\r|\\n)/;\nconst reTrailingNewline = /(?:\\r\\n|\\r|\\n)[ \\t]*$/;\nconst reStartsWithNewlineOrIsEmpty = /^(?:[\\r\\n]|$)/;\nconst reDetectIndentation = /(?:\\r\\n|\\r|\\n)([ \\t]*)(?:[^ \\t\\r\\n]|$)/;\nconst reOnlyWhitespaceWithAtLeastOneNewline = /^[ \\t]*[\\r\\n][ \\t\\r\\n]*$/;\n\nfunction _outdentArray(\n  strings: ReadonlyArray<string>,\n  firstInterpolatedValueSetsIndentationLevel: boolean,\n  options: Options,\n) {\n  // If first interpolated value is a reference to outdent,\n  // determine indentation level from the indentation of the interpolated value.\n  let indentationLevel = 0;\n\n  const match = strings[0].match(reDetectIndentation);\n  if (match) {\n    indentationLevel = match[1].length;\n  }\n\n  const reSource = `(\\\\r\\\\n|\\\\r|\\\\n).{0,${indentationLevel}}`;\n  const reMatchIndent = new RegExp(reSource, \"g\");\n\n  if (firstInterpolatedValueSetsIndentationLevel) {\n    strings = strings.slice(1);\n  }\n\n  const { newline, trimLeadingNewline, trimTrailingNewline } = options;\n  const normalizeNewlines = typeof newline === \"string\";\n  const l = strings.length;\n  const outdentedStrings = strings.map((v, i) => {\n    // Remove leading indentation from all lines\n    v = v.replace(reMatchIndent, \"$1\");\n    // Trim a leading newline from the first string\n    if (i === 0 && trimLeadingNewline) {\n      v = v.replace(reLeadingNewline, \"\");\n    }\n    // Trim a trailing newline from the last string\n    if (i === l - 1 && trimTrailingNewline) {\n      v = v.replace(reTrailingNewline, \"\");\n    }\n    // Normalize newlines\n    if (normalizeNewlines) {\n      v = v.replace(/\\r\\n|\\n|\\r/g, (_) => newline as string);\n    }\n    return v;\n  });\n  return outdentedStrings;\n}\n\nfunction concatStringsAndValues(\n  strings: ReadonlyArray<string>,\n  values: ReadonlyArray<any>,\n): string {\n  let ret = \"\";\n  for (let i = 0, l = strings.length; i < l; i++) {\n    ret += strings[i];\n    if (i < l - 1) {\n      ret += values[i];\n    }\n  }\n  return ret;\n}\n\nfunction isTemplateStringsArray(v: any): v is TemplateStringsArray {\n  return has(v, \"raw\") && has(v, \"length\");\n}\n\n/**\n * It is assumed that opts will not change.  If this is a problem, clone your options object and pass the clone to\n * makeInstance\n * @param options\n * @return {outdent}\n */\nfunction createInstance(options: Options): Outdent {\n  /** Cache of pre-processed template literal arrays */\n  const arrayAutoIndentCache = createWeakMap<\n    TemplateStringsArray,\n    Array<string>\n  >();\n  /**\n     * Cache of pre-processed template literal arrays, where first interpolated value is a reference to outdent,\n     * before interpolated values are injected.\n     */\n  const arrayFirstInterpSetsIndentCache = createWeakMap<\n    TemplateStringsArray,\n    Array<string>\n  >();\n\n  /* tslint:disable:no-shadowed-variable */\n  function outdent(\n    stringsOrOptions: TemplateStringsArray,\n    ...values: Array<any>\n  ): string;\n  function outdent(stringsOrOptions: Options): Outdent;\n  function outdent(\n    stringsOrOptions: TemplateStringsArray | Options,\n    ...values: Array<any>\n  ): string | Outdent {\n    /* tslint:enable:no-shadowed-variable */\n    if (isTemplateStringsArray(stringsOrOptions)) {\n      const strings = stringsOrOptions;\n\n      // Is first interpolated value a reference to outdent, alone on its own line, without any preceding non-whitespace?\n      const firstInterpolatedValueSetsIndentationLevel =\n        (values[0] === outdent || values[0] === defaultOutdent) &&\n        reOnlyWhitespaceWithAtLeastOneNewline.test(strings[0]) &&\n        reStartsWithNewlineOrIsEmpty.test(strings[1]);\n\n      // Perform outdentation\n      const cache = firstInterpolatedValueSetsIndentationLevel\n        ? arrayFirstInterpSetsIndentCache\n        : arrayAutoIndentCache;\n      let renderedArray = cache.get(strings);\n      if (!renderedArray) {\n        renderedArray = _outdentArray(\n          strings,\n          firstInterpolatedValueSetsIndentationLevel,\n          options,\n        );\n        cache.set(strings, renderedArray);\n      }\n      /** If no interpolated values, skip concatenation step */\n      if (values.length === 0) {\n        return renderedArray[0];\n      }\n      /** Concatenate string literals with interpolated values */\n      const rendered = concatStringsAndValues(\n        renderedArray,\n        firstInterpolatedValueSetsIndentationLevel ? values.slice(1) : values,\n      );\n\n      return rendered;\n    } else {\n      // Create and return a new instance of outdent with the given options\n      return createInstance(\n        extend(extend({}, options), stringsOrOptions || {}),\n      );\n    }\n  }\n\n  const fullOutdent = extend(outdent, {\n    string(str: string): string {\n      return _outdentArray([str], false, options)[0];\n    },\n  });\n\n  return fullOutdent;\n}\n\nconst defaultOutdent = createInstance({\n  trimLeadingNewline: true,\n  trimTrailingNewline: true,\n});\n\nexport interface Outdent {\n  /**\n     * Remove indentation from a template literal.\n     */\n  (strings: TemplateStringsArray, ...values: Array<any>): string;\n  /**\n     * Create and return a new Outdent instance with the given options.\n     */\n  (options: Options): Outdent;\n\n  /**\n     * Remove indentation from a string\n     */\n  string(str: string): string;\n\n  // /**\n  //  * Remove indentation from a template literal, but return a tuple of the\n  //  * outdented TemplateStringsArray and\n  //  */\n  // pass(strings: TemplateStringsArray, ...values: Array<any>): [TemplateStringsArray, ...Array<any>];\n}\nexport interface Options {\n  trimLeadingNewline?: boolean;\n  trimTrailingNewline?: boolean;\n  /**\n     * Normalize all newlines in the template literal to this value.\n     * \n     * If `null`, newlines are left untouched.\n     * \n     * Newlines that get normalized are '\\r\\n', '\\r', and '\\n'.\n     * \n     * Newlines within interpolated values are *never* normalized.\n     * \n     * Although intended for normalizing to '\\n' or '\\r\\n',\n     * you can also set to any string; for example ' '.\n     */\n  newline?: string | null;\n}\n\n// Named exports.  Simple and preferred.\n// import outdent from 'outdent';\nexport default defaultOutdent;\n// import {outdent} from 'outdent';\nexport { defaultOutdent as outdent };\n\n// In CommonJS environments, enable `var outdent = require('outdent');` by\n// replacing the exports object.\n// Make sure that our replacement includes the named exports from above.\ndeclare var module: any;\nif (typeof module !== \"undefined\") {\n  // In webpack harmony-modules environments, module.exports is read-only,\n  // so we fail gracefully.\n  try {\n    module.exports = defaultOutdent;\n    Object.defineProperty(defaultOutdent, \"__esModule\", { value: true });\n    (defaultOutdent as any).default = defaultOutdent;\n    (defaultOutdent as any).outdent = defaultOutdent;\n  } catch (e) {}\n}\n"]},"metadata":{},"sourceType":"module"}