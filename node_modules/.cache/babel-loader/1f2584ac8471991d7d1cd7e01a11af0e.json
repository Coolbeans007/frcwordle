{"ast":null,"code":"/*! https://mths.be/cssesc v3.0.0 by @mathias */\n'use strict';\n\nvar object = {};\nvar hasOwnProperty = object.hasOwnProperty;\n\nvar merge = function merge(options, defaults) {\n  if (!options) {\n    return defaults;\n  }\n\n  var result = {};\n\n  for (var key in defaults) {\n    // `if (defaults.hasOwnProperty(key) { … }` is not needed here, since\n    // only recognized option names are used.\n    result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];\n  }\n\n  return result;\n};\n\nvar regexAnySingleEscape = /[ -,\\.\\/:-@\\[-\\^`\\{-~]/;\nvar regexSingleEscape = /[ -,\\.\\/:-@\\[\\]\\^`\\{-~]/;\nvar regexAlwaysEscape = /['\"\\\\]/;\nvar regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g; // https://mathiasbynens.be/notes/css-escapes#css\n\nvar cssesc = function cssesc(string, options) {\n  options = merge(options, cssesc.options);\n\n  if (options.quotes != 'single' && options.quotes != 'double') {\n    options.quotes = 'single';\n  }\n\n  var quote = options.quotes == 'double' ? '\"' : '\\'';\n  var isIdentifier = options.isIdentifier;\n  var firstChar = string.charAt(0);\n  var output = '';\n  var counter = 0;\n  var length = string.length;\n\n  while (counter < length) {\n    var character = string.charAt(counter++);\n    var codePoint = character.charCodeAt();\n    var value = void 0; // If it’s not a printable ASCII character…\n\n    if (codePoint < 0x20 || codePoint > 0x7E) {\n      if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n        // It’s a high surrogate, and there is a next character.\n        var extra = string.charCodeAt(counter++);\n\n        if ((extra & 0xFC00) == 0xDC00) {\n          // next character is low surrogate\n          codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n        } else {\n          // It’s an unmatched surrogate; only append this code unit, in case\n          // the next code unit is the high surrogate of a surrogate pair.\n          counter--;\n        }\n      }\n\n      value = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n    } else {\n      if (options.escapeEverything) {\n        if (regexAnySingleEscape.test(character)) {\n          value = '\\\\' + character;\n        } else {\n          value = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n        }\n      } else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n        value = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n      } else if (character == '\\\\' || !isIdentifier && (character == '\"' && quote == character || character == '\\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {\n        value = '\\\\' + character;\n      } else {\n        value = character;\n      }\n    }\n\n    output += value;\n  }\n\n  if (isIdentifier) {\n    if (/^-[-\\d]/.test(output)) {\n      output = '\\\\-' + output.slice(1);\n    } else if (/\\d/.test(firstChar)) {\n      output = '\\\\3' + firstChar + ' ' + output.slice(1);\n    }\n  } // Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n  // since they’re redundant. Note that this is only possible if the escape\n  // sequence isn’t preceded by an odd number of backslashes.\n\n\n  output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {\n    if ($1 && $1.length % 2) {\n      // It’s not safe to remove the space, so don’t.\n      return $0;\n    } // Strip the space.\n\n\n    return ($1 || '') + $2;\n  });\n\n  if (!isIdentifier && options.wrap) {\n    return quote + output + quote;\n  }\n\n  return output;\n}; // Expose default options (so they can be overridden globally).\n\n\ncssesc.options = {\n  'escapeEverything': false,\n  'isIdentifier': false,\n  'quotes': 'single',\n  'wrap': false\n};\ncssesc.version = '3.0.0';\nmodule.exports = cssesc;","map":{"version":3,"sources":["/Users/ntwrkman/Desktop/frcwordl/node_modules/cssesc/cssesc.js"],"names":["object","hasOwnProperty","merge","options","defaults","result","key","call","regexAnySingleEscape","regexSingleEscape","regexAlwaysEscape","regexExcessiveSpaces","cssesc","string","quotes","quote","isIdentifier","firstChar","charAt","output","counter","length","character","codePoint","charCodeAt","value","extra","toString","toUpperCase","escapeEverything","test","slice","replace","$0","$1","$2","wrap","version","module","exports"],"mappings":"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","sourcesContent":["/*! https://mths.be/cssesc v3.0.0 by @mathias */\n'use strict';\n\nvar object = {};\nvar hasOwnProperty = object.hasOwnProperty;\nvar merge = function merge(options, defaults) {\n\tif (!options) {\n\t\treturn defaults;\n\t}\n\tvar result = {};\n\tfor (var key in defaults) {\n\t\t// `if (defaults.hasOwnProperty(key) { … }` is not needed here, since\n\t\t// only recognized option names are used.\n\t\tresult[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];\n\t}\n\treturn result;\n};\n\nvar regexAnySingleEscape = /[ -,\\.\\/:-@\\[-\\^`\\{-~]/;\nvar regexSingleEscape = /[ -,\\.\\/:-@\\[\\]\\^`\\{-~]/;\nvar regexAlwaysEscape = /['\"\\\\]/;\nvar regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n// https://mathiasbynens.be/notes/css-escapes#css\nvar cssesc = function cssesc(string, options) {\n\toptions = merge(options, cssesc.options);\n\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\toptions.quotes = 'single';\n\t}\n\tvar quote = options.quotes == 'double' ? '\"' : '\\'';\n\tvar isIdentifier = options.isIdentifier;\n\n\tvar firstChar = string.charAt(0);\n\tvar output = '';\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar character = string.charAt(counter++);\n\t\tvar codePoint = character.charCodeAt();\n\t\tvar value = void 0;\n\t\t// If it’s not a printable ASCII character…\n\t\tif (codePoint < 0x20 || codePoint > 0x7E) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n\t\t\t\t// It’s a high surrogate, and there is a next character.\n\t\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t\t// next character is low surrogate\n\t\t\t\t\tcodePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n\t\t\t\t} else {\n\t\t\t\t\t// It’s an unmatched surrogate; only append this code unit, in case\n\t\t\t\t\t// the next code unit is the high surrogate of a surrogate pair.\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t} else {\n\t\t\tif (options.escapeEverything) {\n\t\t\t\tif (regexAnySingleEscape.test(character)) {\n\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t} else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t} else if (character == '\\\\' || !isIdentifier && (character == '\"' && quote == character || character == '\\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {\n\t\t\t\tvalue = '\\\\' + character;\n\t\t\t} else {\n\t\t\t\tvalue = character;\n\t\t\t}\n\t\t}\n\t\toutput += value;\n\t}\n\n\tif (isIdentifier) {\n\t\tif (/^-[-\\d]/.test(output)) {\n\t\t\toutput = '\\\\-' + output.slice(1);\n\t\t} else if (/\\d/.test(firstChar)) {\n\t\t\toutput = '\\\\3' + firstChar + ' ' + output.slice(1);\n\t\t}\n\t}\n\n\t// Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n\t// since they’re redundant. Note that this is only possible if the escape\n\t// sequence isn’t preceded by an odd number of backslashes.\n\toutput = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {\n\t\tif ($1 && $1.length % 2) {\n\t\t\t// It’s not safe to remove the space, so don’t.\n\t\t\treturn $0;\n\t\t}\n\t\t// Strip the space.\n\t\treturn ($1 || '') + $2;\n\t});\n\n\tif (!isIdentifier && options.wrap) {\n\t\treturn quote + output + quote;\n\t}\n\treturn output;\n};\n\n// Expose default options (so they can be overridden globally).\ncssesc.options = {\n\t'escapeEverything': false,\n\t'isIdentifier': false,\n\t'quotes': 'single',\n\t'wrap': false\n};\n\ncssesc.version = '3.0.0';\n\nmodule.exports = cssesc;\n"]},"metadata":{},"sourceType":"script"}